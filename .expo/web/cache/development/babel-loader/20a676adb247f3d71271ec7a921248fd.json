{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport React, { useCallback, useState, useEffect, useRef } from 'react';\nimport { collection, query, limit, onSnapshot, orderBy } from 'firebase/firestore';\nimport { firestore } from \"../../firebase\";\nvar now = Date.now();\n\nvar useInfiniteSnapshotListener = function useInfiniteSnapshotListener(chatRoom) {\n  var unsubscribes = useRef([]);\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      messages = _useState2[0],\n      setMessages = _useState2[1];\n\n  var messageRef = collection(firestore, \"chat/\" + chatRoom + \"/messages\");\n  var registLatestMessageListener = useCallback(function () {\n    return onSnapshot(query(messageRef, startAfter(now), orderBy(\"createdAt\", \"asc\"), limit(limit)), function (snapshot) {\n      dispMsgSnap(snapshot);\n    });\n  }, []);\n  var registPastMessageListener = useCallback(function (startAfter) {\n    return onSnapshot(query(messageRef, startAfter(startAfter), orderBy(\"createdAt\", \"desc\"), limit(limit)), function (snapshot) {\n      dispMsgSnap(snapshot);\n    });\n  }, []);\n  var initRead = useCallback(function () {\n    unsubscribes.current.push(registLatestMessageListener());\n    unsubscribes.current.push(registPastMessageListener(now));\n  }, [registPastMessageListener]);\n  var lastMessageDate = messages[messages.length - 1].createdAt;\n  var readMore = useCallback(function () {\n    unsubscribes.current.push(registPastMessageListener(lastMessageDate));\n  }, [registPastMessageListener, lastMessageDate]);\n  var clear = useCallback(function () {\n    for (var _iterator = _createForOfIteratorHelperLoose(unsubscribes.current), _step; !(_step = _iterator()).done;) {\n      var unsubscribe = _step.value;\n      unsubscribe();\n    }\n  }, []);\n  useEffect(function () {\n    return function () {\n      clear();\n    };\n  }, [clear]);\n\n  var dispMsgSnap = function dispMsgSnap(snapshot) {\n    snapshot.docChanges().forEach(function (change) {\n      var id = change.doc.id;\n      var chat = change.doc.data();\n      var newMessage = {\n        _id: id,\n        text: chat.text,\n        createdAt: chat.createdAt.toDate(),\n        user: {\n          _id: chat.user._id,\n          name: chat.user.name,\n          avatar: chat.avatar\n        }\n      };\n\n      switch (change.type) {\n        case 'added':\n          msgAppend(newMessage);\n          break;\n\n        case 'modified':\n          break;\n\n        case 'removed':\n          break;\n\n        default:\n          break;\n      }\n    });\n  };\n\n  var msgAppend = function msgAppend() {\n    var newMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    setMessages(function (previousMessages) {\n      return GiftedChat.append(previousMessages, newMessage);\n    });\n  };\n\n  return {\n    initRead: initRead,\n    readMore: readMore,\n    messages: messages\n  };\n};\n\nvar messageListener = function messageListener(chatRoom) {\n  var messages, messageRef, q, unsubscribe;\n  return _regeneratorRuntime.async(function messageListener$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          messageRef = collection(firestore, \"chat/\" + user.chatRoom + \"/messages\");\n          q = query(messageRef, orderBy(\"createdAt\", \"desc\"), limit(1));\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(onSnapshot(q, function (snapshot) {\n            var targets = snapshot.docs.map(function (doc) {\n              return _objectSpread({}, doc.data());\n            });\n\n            if (targets.length == 0) {\n              user.messages = {\n                _id: \"\",\n                createdAt: \"\",\n                text: \"\",\n                user: {\n                  _id: \"\",\n                  avatar: \"\",\n                  name: \"\"\n                }\n              };\n            } else {\n              console.log(targets);\n              user.messages = targets;\n            }\n          }));\n\n        case 4:\n          unsubscribe = _context.sent;\n          return _context.abrupt(\"return\", messages);\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\n\nexport { useInfiniteSnapshotListener, messageListener };","map":{"version":3,"sources":["C:/Users/yumej/github/nikoichi/src/components/ChatListener.js"],"names":["React","useCallback","useState","useEffect","useRef","collection","query","limit","onSnapshot","orderBy","firestore","now","Date","useInfiniteSnapshotListener","chatRoom","unsubscribes","messages","setMessages","messageRef","registLatestMessageListener","startAfter","snapshot","dispMsgSnap","registPastMessageListener","initRead","current","push","lastMessageDate","length","createdAt","readMore","clear","unsubscribe","docChanges","forEach","change","id","doc","chat","data","newMessage","_id","text","toDate","user","name","avatar","type","msgAppend","previousMessages","GiftedChat","append","messageListener","q","targets","docs","map","console","log"],"mappings":"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","sourcesContent":["import React, { useCallback, useState, useEffect, useRef } from 'react';\r\nimport { collection, query, limit, onSnapshot, orderBy } from 'firebase/firestore';\r\n\r\nimport { firestore } from '../../firebase';\r\n\r\nconst now = Date.now();\r\nconst useInfiniteSnapshotListener = (chatRoom) => {\r\n\r\n    const unsubscribes = useRef([]);\r\n    const [messages, setMessages] = useState([]);\r\n    const messageRef = collection(firestore, `chat/${chatRoom}/messages`);  // メッセージ登録用\r\n\r\n    // 未来（最新メッセージ）の購読リスナー\r\n    const registLatestMessageListener = useCallback(() => {\r\n        return onSnapshot(query(messageRef, startAfter(now), orderBy(\"createdAt\",\"asc\"), limit(limit)), (snapshot) => {dispMsgSnap(snapshot)});\r\n    },[]);\r\n\r\n    //過去メッセージの購読リスナー\r\n    const registPastMessageListener = useCallback((startAfter) => {\r\n        return onSnapshot(query(messageRef, startAfter(startAfter), orderBy(\"createdAt\",\"desc\"), limit(limit)), (snapshot) => {dispMsgSnap(snapshot)});\r\n    },[]);\r\n\r\n    // 初回ロード\r\n    const initRead = useCallback(() => {\r\n        // 未来のメッセージを購読する\r\n        unsubscribes.current.push(registLatestMessageListener());\r\n        // 現時刻よりも古いデータを一定数、購読する\r\n        unsubscribes.current.push(registPastMessageListener(now));\r\n    },[registPastMessageListener]);\r\n\r\n    // スクロール時、追加購読するためのリスナー\r\n    const lastMessageDate = messages[messages.length - 1].createdAt;\r\n    const readMore = useCallback(() => {\r\n        unsubscribes.current.push(registPastMessageListener(lastMessageDate));\r\n    },[registPastMessageListener,lastMessageDate]);\r\n\r\n    // 登録解除(Unmount時に解除）\r\n    const clear = useCallback(() => {\r\n        for(const unsubscribe of unsubscribes.current){\r\n            unsubscribe();\r\n        }\r\n    },[]);\r\n\r\n    useEffect(() => { return () => { clear(); }; }, [clear]);\r\n\r\n\r\n    const dispMsgSnap = (snapshot) => {\r\n        // 取得したメッセージを表示できるように加工\r\n        snapshot.docChanges().forEach((change) => {\r\n            const id = change.doc.id;\r\n            const chat = change.doc.data();\r\n            const newMessage = {\r\n            _id: id,\r\n            text: chat.text,\r\n            createdAt: chat.createdAt.toDate(),\r\n            user: {\r\n                _id: chat.user._id,\r\n                name: chat.user.name,\r\n                avatar: chat.avatar\r\n            }\r\n            };\r\n            switch(change.type){\r\n            case 'added':\r\n                msgAppend(newMessage);\r\n                break;\r\n            case 'modified':\r\n                break;\r\n            case 'removed':\r\n                break;\r\n            default: \r\n                break;\r\n            }\r\n        });\r\n    };\r\n    \r\n    const msgAppend = (newMessage = []) => {\r\n        // メッセージを連結\r\n        setMessages((previousMessages) => GiftedChat.append(previousMessages,newMessage));\r\n    };\r\n\r\n    return { initRead, readMore, messages };\r\n};\r\n\r\n\r\nconst messageListener = async(chatRoom) => {\r\n\r\n    let messages;\r\n    const messageRef = collection(firestore, `chat/${user.chatRoom}/messages`);\r\n      const q = query(messageRef, orderBy(\"createdAt\",\"desc\"), limit(1));\r\n      const unsubscribe = await onSnapshot(q, (snapshot) => {\r\n        const targets = snapshot.docs.map((doc) => {\r\n          return {...doc.data()};\r\n        });\r\n        if(targets.length == 0){\r\n          user.messages = {\r\n            _id: \"\",\r\n            createdAt: \"\",\r\n            text: \"\",\r\n            user: {\r\n              _id: \"\",\r\n              avatar: \"\",\r\n              name: \"\",\r\n            }\r\n          }\r\n        }else{\r\n          console.log(targets);\r\n          user.messages = targets;\r\n        }\r\n      });\r\n    return messages;\r\n}\r\n\r\n\r\n\r\nexport { useInfiniteSnapshotListener, messageListener };"]},"metadata":{},"sourceType":"module"}