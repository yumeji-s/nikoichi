var $jEbhA$reactstatelyutils = require("@react-stately/utils");
var $jEbhA$react = require("react");

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $64fba30eebf21c6c$exports = {};

$parcel$export($64fba30eebf21c6c$exports, "useRadioGroupState", () => $64fba30eebf21c6c$export$bca9d026f8e704eb);


let $64fba30eebf21c6c$var$instance = Math.round(Math.random() * 10000000000);
let $64fba30eebf21c6c$var$i = 0;
function $64fba30eebf21c6c$export$bca9d026f8e704eb(props) {
    // Preserved here for backward compatibility. React Aria now generates the name instead of stately.
    let name = $jEbhA$react.useMemo(()=>props.name || `radio-group-${$64fba30eebf21c6c$var$instance}-${++$64fba30eebf21c6c$var$i}`
    , [
        props.name
    ]);
    let [selectedValue, setSelected] = $jEbhA$reactstatelyutils.useControlledState(props.value, props.defaultValue, props.onChange);
    let [lastFocusedValue, setLastFocusedValue] = $jEbhA$react.useState(null);
    let setSelectedValue = (value)=>{
        if (!props.isReadOnly && !props.isDisabled) setSelected(value);
    };
    return {
        name: name,
        selectedValue: selectedValue,
        setSelectedValue: setSelectedValue,
        lastFocusedValue: lastFocusedValue,
        setLastFocusedValue: setLastFocusedValue,
        isDisabled: props.isDisabled || false,
        isReadOnly: props.isReadOnly || false
    };
}


$parcel$exportWildcard(module.exports, $64fba30eebf21c6c$exports);


//# sourceMappingURL=main.js.map
