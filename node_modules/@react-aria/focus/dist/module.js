import $6saFI$react, {useRef as $6saFI$useRef, useContext as $6saFI$useContext, useEffect as $6saFI$useEffect, useState as $6saFI$useState} from "react";
import {useLayoutEffect as $6saFI$useLayoutEffect, runAfterTransition as $6saFI$runAfterTransition, focusWithoutScrolling as $6saFI$focusWithoutScrolling, mergeProps as $6saFI$mergeProps, useSyncRef as $6saFI$useSyncRef} from "@react-aria/utils";
import {getInteractionModality as $6saFI$getInteractionModality, isFocusVisible as $6saFI$isFocusVisible, useFocusVisibleListener as $6saFI$useFocusVisibleListener, useFocus as $6saFI$useFocus, useFocusWithin as $6saFI$useFocusWithin, useKeyboard as $6saFI$useKeyboard} from "@react-aria/interactions";
import $6saFI$clsx from "clsx";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $14e5c84cbc2e6e2e$exports = {};

$parcel$export($14e5c84cbc2e6e2e$exports, "FocusScope", () => $14e5c84cbc2e6e2e$export$20e40289641fbbb6);
$parcel$export($14e5c84cbc2e6e2e$exports, "useFocusManager", () => $14e5c84cbc2e6e2e$export$10c5169755ce7bd7);
$parcel$export($14e5c84cbc2e6e2e$exports, "getFocusableTreeWalker", () => $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa);
$parcel$export($14e5c84cbc2e6e2e$exports, "createFocusManager", () => $14e5c84cbc2e6e2e$export$c5251b9e124bf29);
var $1159c3b6ba210e4f$exports = {};

$parcel$export($1159c3b6ba210e4f$exports, "focusSafely", () => $1159c3b6ba210e4f$export$80f3e147d781571c);


function $1159c3b6ba210e4f$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transitions that are currently occurring on
    // the page before shifting focus. This avoids issues with VoiceOver on iOS
    // causing the page to scroll when moving focus if the element is transitioning
    // from off the screen.
    if ($6saFI$getInteractionModality() === 'virtual') {
        let lastFocusedElement = document.activeElement;
        $6saFI$runAfterTransition(()=>{
            // If focus did not move and the element is still in the document, focus it.
            if (document.activeElement === lastFocusedElement && document.contains(element)) $6saFI$focusWithoutScrolling(element);
        });
    } else $6saFI$focusWithoutScrolling(element);
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $985a2847ebcbb615$var$isStyleVisible(element) {
    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;
    let { display: display , visibility: visibility  } = element.style;
    let isVisible = display !== 'none' && visibility !== 'hidden' && visibility !== 'collapse';
    if (isVisible) {
        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;
        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);
        isVisible = computedDisplay !== 'none' && computedVisibility !== 'hidden' && computedVisibility !== 'collapse';
    }
    return isVisible;
}
function $985a2847ebcbb615$var$isAttributeVisible(element, childElement) {
    return !element.hasAttribute('hidden') && (element.nodeName === 'DETAILS' && childElement && childElement.nodeName !== 'SUMMARY' ? element.hasAttribute('open') : true);
}
function $985a2847ebcbb615$export$e989c0fffaa6b27a(element, childElement) {
    return element.nodeName !== '#comment' && $985a2847ebcbb615$var$isStyleVisible(element) && $985a2847ebcbb615$var$isAttributeVisible(element, childElement) && (!element.parentElement || $985a2847ebcbb615$export$e989c0fffaa6b27a(element.parentElement, element));
}




const $14e5c84cbc2e6e2e$var$FocusContext = /*#__PURE__*/ $6saFI$react.createContext(null);
let $14e5c84cbc2e6e2e$var$activeScope = null;
let $14e5c84cbc2e6e2e$var$scopes = new Map();
function $14e5c84cbc2e6e2e$export$20e40289641fbbb6(props) {
    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;
    let startRef = $6saFI$useRef();
    let endRef = $6saFI$useRef();
    let scopeRef = $6saFI$useRef([]);
    let ctx = $6saFI$useContext($14e5c84cbc2e6e2e$var$FocusContext);
    let parentScope = ctx === null || ctx === void 0 ? void 0 : ctx.scopeRef;
    $6saFI$useLayoutEffect(()=>{
        // Find all rendered nodes between the sentinels and add them to the scope.
        let node = startRef.current.nextSibling;
        let nodes = [];
        while(node && node !== endRef.current){
            nodes.push(node);
            node = node.nextSibling;
        }
        scopeRef.current = nodes;
    }, [
        children,
        parentScope
    ]);
    $6saFI$useLayoutEffect(()=>{
        $14e5c84cbc2e6e2e$var$scopes.set(scopeRef, parentScope);
        return ()=>{
            // Restore the active scope on unmount if this scope or a descendant scope is active.
            // Parent effect cleanups run before children, so we need to check if the
            // parent scope actually still exists before restoring the active scope to it.
            if ((scopeRef === $14e5c84cbc2e6e2e$var$activeScope || $14e5c84cbc2e6e2e$var$isAncestorScope(scopeRef, $14e5c84cbc2e6e2e$var$activeScope)) && (!parentScope || $14e5c84cbc2e6e2e$var$scopes.has(parentScope))) $14e5c84cbc2e6e2e$var$activeScope = parentScope;
            $14e5c84cbc2e6e2e$var$scopes.delete(scopeRef);
        };
    }, [
        scopeRef,
        parentScope
    ]);
    $14e5c84cbc2e6e2e$var$useFocusContainment(scopeRef, contain);
    $14e5c84cbc2e6e2e$var$useRestoreFocus(scopeRef, restoreFocus, contain);
    $14e5c84cbc2e6e2e$var$useAutoFocus(scopeRef, autoFocus);
    let focusManager = $14e5c84cbc2e6e2e$var$createFocusManagerForScope(scopeRef);
    return(/*#__PURE__*/ $6saFI$react.createElement($14e5c84cbc2e6e2e$var$FocusContext.Provider, {
        value: {
            scopeRef: scopeRef,
            focusManager: focusManager
        }
    }, /*#__PURE__*/ $6saFI$react.createElement("span", {
        "data-focus-scope-start": true,
        hidden: true,
        ref: startRef
    }), children, /*#__PURE__*/ $6saFI$react.createElement("span", {
        "data-focus-scope-end": true,
        hidden: true,
        ref: endRef
    })));
}
function $14e5c84cbc2e6e2e$export$10c5169755ce7bd7() {
    var ref;
    return (ref = $6saFI$useContext($14e5c84cbc2e6e2e$var$FocusContext)) === null || ref === void 0 ? void 0 : ref.focusManager;
}
function $14e5c84cbc2e6e2e$var$createFocusManagerForScope(scopeRef) {
    return {
        focusNext (opts = {
        }) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[0].previousElementSibling;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa($14e5c84cbc2e6e2e$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = $14e5c84cbc2e6e2e$var$isElementInScope(node, scope) ? node : sentinel;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = sentinel;
                nextNode = walker.nextNode();
            }
            if (nextNode) $14e5c84cbc2e6e2e$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {
        }) {
            let scope = scopeRef.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let sentinel = scope[scope.length - 1].nextElementSibling;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa($14e5c84cbc2e6e2e$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = $14e5c84cbc2e6e2e$var$isElementInScope(node, scope) ? node : sentinel;
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = sentinel;
                previousNode = walker.previousNode();
            }
            if (previousNode) $14e5c84cbc2e6e2e$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {
        }) {
            let scope = scopeRef.current;
            let { tabbable: tabbable  } = opts;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa($14e5c84cbc2e6e2e$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = scope[0].previousElementSibling;
            let nextNode = walker.nextNode();
            if (nextNode) $14e5c84cbc2e6e2e$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {
        }) {
            let scope = scopeRef.current;
            let { tabbable: tabbable  } = opts;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa($14e5c84cbc2e6e2e$var$getScopeRoot(scope), {
                tabbable: tabbable
            }, scope);
            walker.currentNode = scope[scope.length - 1].nextElementSibling;
            let previousNode = walker.previousNode();
            if (previousNode) $14e5c84cbc2e6e2e$var$focusElement(previousNode, true);
            return previousNode;
        }
    };
}
const $14e5c84cbc2e6e2e$var$focusableElements = [
    'input:not([disabled]):not([type=hidden])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]'
];
const $14e5c84cbc2e6e2e$var$FOCUSABLE_ELEMENT_SELECTOR = $14e5c84cbc2e6e2e$var$focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';
$14e5c84cbc2e6e2e$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const $14e5c84cbc2e6e2e$var$TABBABLE_ELEMENT_SELECTOR = $14e5c84cbc2e6e2e$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $14e5c84cbc2e6e2e$var$getScopeRoot(scope) {
    return scope[0].parentElement;
}
function $14e5c84cbc2e6e2e$var$useFocusContainment(scopeRef, contain) {
    let focusedNode = $6saFI$useRef();
    let raf = $6saFI$useRef(null);
    $6saFI$useLayoutEffect(()=>{
        let scope1 = scopeRef.current;
        if (!contain) return;
        // Handle the Tab key to contain focus within the scope
        let onKeyDown = (e)=>{
            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || scopeRef !== $14e5c84cbc2e6e2e$var$activeScope) return;
            let focusedElement = document.activeElement;
            let scope = scopeRef.current;
            if (!$14e5c84cbc2e6e2e$var$isElementInScope(focusedElement, scope)) return;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa($14e5c84cbc2e6e2e$var$getScopeRoot(scope), {
                tabbable: true
            }, scope);
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!nextElement) {
                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;
                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            }
            e.preventDefault();
            if (nextElement) $14e5c84cbc2e6e2e$var$focusElement(nextElement, true);
        };
        let onFocus = (e)=>{
            // If focusing an element in a child scope of the currently active scope, the child becomes active.
            // Moving out of the active scope to an ancestor is not allowed.
            if (!$14e5c84cbc2e6e2e$var$activeScope || $14e5c84cbc2e6e2e$var$isAncestorScope($14e5c84cbc2e6e2e$var$activeScope, scopeRef)) {
                $14e5c84cbc2e6e2e$var$activeScope = scopeRef;
                focusedNode.current = e.target;
            } else if (scopeRef === $14e5c84cbc2e6e2e$var$activeScope && !$14e5c84cbc2e6e2e$var$isElementInChildScope(e.target, scopeRef)) {
                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
                // restore focus to the previously focused node or the first tabbable element in the active scope.
                if (focusedNode.current) focusedNode.current.focus();
                else if ($14e5c84cbc2e6e2e$var$activeScope) $14e5c84cbc2e6e2e$var$focusFirstInScope($14e5c84cbc2e6e2e$var$activeScope.current);
            } else if (scopeRef === $14e5c84cbc2e6e2e$var$activeScope) focusedNode.current = e.target;
        };
        let onBlur = (e)=>{
            // Firefox doesn't shift focus back to the Dialog properly without this
            raf.current = requestAnimationFrame(()=>{
                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                if (scopeRef === $14e5c84cbc2e6e2e$var$activeScope && !$14e5c84cbc2e6e2e$var$isElementInChildScope(document.activeElement, scopeRef)) {
                    $14e5c84cbc2e6e2e$var$activeScope = scopeRef;
                    focusedNode.current = e.target;
                    focusedNode.current.focus();
                }
            });
        };
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('focusin', onFocus, false);
        scope1.forEach((element)=>element.addEventListener('focusin', onFocus, false)
        );
        scope1.forEach((element)=>element.addEventListener('focusout', onBlur, false)
        );
        return ()=>{
            document.removeEventListener('keydown', onKeyDown, false);
            document.removeEventListener('focusin', onFocus, false);
            scope1.forEach((element)=>element.removeEventListener('focusin', onFocus, false)
            );
            scope1.forEach((element)=>element.removeEventListener('focusout', onBlur, false)
            );
        };
    }, [
        scopeRef,
        contain
    ]);
    // eslint-disable-next-line arrow-body-style
    $6saFI$useEffect(()=>{
        return ()=>cancelAnimationFrame(raf.current)
        ;
    }, [
        raf
    ]);
}
function $14e5c84cbc2e6e2e$var$isElementInAnyScope(element) {
    for (let scope of $14e5c84cbc2e6e2e$var$scopes.keys()){
        if ($14e5c84cbc2e6e2e$var$isElementInScope(element, scope.current)) return true;
    }
    return false;
}
function $14e5c84cbc2e6e2e$var$isElementInScope(element, scope) {
    return scope.some((node)=>node.contains(element)
    );
}
function $14e5c84cbc2e6e2e$var$isElementInChildScope(element, scope) {
    // node.contains in isElementInScope covers child scopes that are also DOM children,
    // but does not cover child scopes in portals.
    for (let s of $14e5c84cbc2e6e2e$var$scopes.keys()){
        if ((s === scope || $14e5c84cbc2e6e2e$var$isAncestorScope(scope, s)) && $14e5c84cbc2e6e2e$var$isElementInScope(element, s.current)) return true;
    }
    return false;
}
function $14e5c84cbc2e6e2e$var$isAncestorScope(ancestor, scope) {
    let parent = $14e5c84cbc2e6e2e$var$scopes.get(scope);
    if (!parent) return false;
    if (parent === ancestor) return true;
    return $14e5c84cbc2e6e2e$var$isAncestorScope(ancestor, parent);
}
function $14e5c84cbc2e6e2e$var$focusElement(element, scroll = false) {
    if (element != null && !scroll) try {
        $1159c3b6ba210e4f$export$80f3e147d781571c(element);
    } catch (err) {
    // ignore
    }
    else if (element != null) try {
        element.focus();
    } catch (err1) {
    // ignore
    }
}
function $14e5c84cbc2e6e2e$var$focusFirstInScope(scope) {
    let sentinel = scope[0].previousElementSibling;
    let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa($14e5c84cbc2e6e2e$var$getScopeRoot(scope), {
        tabbable: true
    }, scope);
    walker.currentNode = sentinel;
    $14e5c84cbc2e6e2e$var$focusElement(walker.nextNode());
}
function $14e5c84cbc2e6e2e$var$useAutoFocus(scopeRef, autoFocus) {
    const autoFocusRef = $6saFI$react.useRef(autoFocus);
    $6saFI$useEffect(()=>{
        if (autoFocusRef.current) {
            $14e5c84cbc2e6e2e$var$activeScope = scopeRef;
            if (!$14e5c84cbc2e6e2e$var$isElementInScope(document.activeElement, $14e5c84cbc2e6e2e$var$activeScope.current)) $14e5c84cbc2e6e2e$var$focusFirstInScope(scopeRef.current);
        }
        autoFocusRef.current = false;
    }, []);
}
function $14e5c84cbc2e6e2e$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
    const nodeToRestoreRef = $6saFI$useRef(typeof document !== 'undefined' ? document.activeElement : null);
    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
    $6saFI$useLayoutEffect(()=>{
        let nodeToRestore = nodeToRestoreRef.current;
        if (!restoreFocus) return;
        // Handle the Tab key so that tabbing out of the scope goes to the next element
        // after the node that had focus when the scope mounted. This is important when
        // using portals for overlays, so that focus goes to the expected element when
        // tabbing out of the overlay.
        let onKeyDown = (e)=>{
            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) return;
            let focusedElement = document.activeElement;
            if (!$14e5c84cbc2e6e2e$var$isElementInScope(focusedElement, scopeRef.current)) return;
            // Create a DOM tree walker that matches all tabbable elements
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa(document.body, {
                tabbable: true
            });
            // Find the next tabbable element after the currently focused element
            walker.currentNode = focusedElement;
            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) nodeToRestore = null;
            // If there is no next element, or it is outside the current scope, move focus to the
            // next element after the node to restore to instead.
            if ((!nextElement || !$14e5c84cbc2e6e2e$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
                walker.currentNode = nodeToRestore;
                // Skip over elements within the scope, in case the scope immediately follows the node to restore.
                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
                while ($14e5c84cbc2e6e2e$var$isElementInScope(nextElement, scopeRef.current))
                e.preventDefault();
                e.stopPropagation();
                if (nextElement) $14e5c84cbc2e6e2e$var$focusElement(nextElement, true);
                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
                // then move focus to the body.
                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
                if (!$14e5c84cbc2e6e2e$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();
                else $14e5c84cbc2e6e2e$var$focusElement(nodeToRestore, true);
            }
        };
        if (!contain) document.addEventListener('keydown', onKeyDown, true);
        return ()=>{
            if (!contain) document.removeEventListener('keydown', onKeyDown, true);
            if (restoreFocus && nodeToRestore && $14e5c84cbc2e6e2e$var$isElementInScope(document.activeElement, scopeRef.current)) requestAnimationFrame(()=>{
                if (document.body.contains(nodeToRestore)) $14e5c84cbc2e6e2e$var$focusElement(nodeToRestore);
            });
        };
    }, [
        scopeRef,
        restoreFocus,
        contain
    ]);
}
function $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa(root, opts, scope) {
    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $14e5c84cbc2e6e2e$var$TABBABLE_ELEMENT_SELECTOR : $14e5c84cbc2e6e2e$var$FOCUSABLE_ELEMENT_SELECTOR;
    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
        acceptNode (node) {
            var ref;
            // Skip nodes inside the starting node.
            if (opts === null || opts === void 0 ? void 0 : (ref = opts.from) === null || ref === void 0 ? void 0 : ref.contains(node)) return NodeFilter.FILTER_REJECT;
            if (node.matches(selector) && $985a2847ebcbb615$export$e989c0fffaa6b27a(node) && (!scope || $14e5c84cbc2e6e2e$var$isElementInScope(node, scope))) return NodeFilter.FILTER_ACCEPT;
            return NodeFilter.FILTER_SKIP;
        }
    });
    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
    return walker;
}
function $14e5c84cbc2e6e2e$export$c5251b9e124bf29(ref) {
    return {
        focusNext (opts = {
        }) {
            let root = ref.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            if (root.contains(node)) walker.currentNode = node;
            let nextNode = walker.nextNode();
            if (!nextNode && wrap) {
                walker.currentNode = root;
                nextNode = walker.nextNode();
            }
            if (nextNode) $14e5c84cbc2e6e2e$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusPrevious (opts = {
        }) {
            let root = ref.current;
            let { from: from , tabbable: tabbable , wrap: wrap  } = opts;
            let node = from || document.activeElement;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            if (root.contains(node)) walker.currentNode = node;
            else {
                let next = $14e5c84cbc2e6e2e$var$last(walker);
                if (next) $14e5c84cbc2e6e2e$var$focusElement(next, true);
                return next;
            }
            let previousNode = walker.previousNode();
            if (!previousNode && wrap) {
                walker.currentNode = root;
                previousNode = $14e5c84cbc2e6e2e$var$last(walker);
            }
            if (previousNode) $14e5c84cbc2e6e2e$var$focusElement(previousNode, true);
            return previousNode;
        },
        focusFirst (opts = {
        }) {
            let root = ref.current;
            let { tabbable: tabbable  } = opts;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            let nextNode = walker.nextNode();
            if (nextNode) $14e5c84cbc2e6e2e$var$focusElement(nextNode, true);
            return nextNode;
        },
        focusLast (opts = {
        }) {
            let root = ref.current;
            let { tabbable: tabbable  } = opts;
            let walker = $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa(root, {
                tabbable: tabbable
            });
            let next = $14e5c84cbc2e6e2e$var$last(walker);
            if (next) $14e5c84cbc2e6e2e$var$focusElement(next, true);
            return next;
        }
    };
}
function $14e5c84cbc2e6e2e$var$last(walker) {
    let next;
    let last;
    do {
        last = walker.lastChild();
        if (last) next = last;
    }while (last)
    return next;
}


var $503734efc0922182$exports = {};

$parcel$export($503734efc0922182$exports, "FocusRing", () => $503734efc0922182$export$1a38b4ad7f578e1d);



var $e63d024ca16f2165$exports = {};

$parcel$export($e63d024ca16f2165$exports, "useFocusRing", () => $e63d024ca16f2165$export$4e328f61c538687f);



function $e63d024ca16f2165$export$4e328f61c538687f(props = {
}) {
    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;
    let state = $6saFI$useRef({
        isFocused: false,
        isFocusVisible: autoFocus || $6saFI$isFocusVisible()
    }).current;
    let [isFocused1, setFocused] = $6saFI$useState(false);
    let [isFocusVisibleState, setFocusVisible] = $6saFI$useState(()=>state.isFocused && state.isFocusVisible
    );
    let updateState = ()=>setFocusVisible(state.isFocused && state.isFocusVisible)
    ;
    let onFocusChange = (isFocused)=>{
        state.isFocused = isFocused;
        setFocused(isFocused);
        updateState();
    };
    $6saFI$useFocusVisibleListener((isFocusVisible)=>{
        state.isFocusVisible = isFocusVisible;
        updateState();
    }, [], {
        isTextInput: isTextInput
    });
    let { focusProps: focusProps  } = $6saFI$useFocus({
        isDisabled: within,
        onFocusChange: onFocusChange
    });
    let { focusWithinProps: focusWithinProps  } = $6saFI$useFocusWithin({
        isDisabled: !within,
        onFocusWithinChange: onFocusChange
    });
    return {
        isFocused: isFocused1,
        isFocusVisible: state.isFocused && isFocusVisibleState,
        focusProps: within ? focusWithinProps : focusProps
    };
}


function $503734efc0922182$export$1a38b4ad7f578e1d(props) {
    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;
    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = $e63d024ca16f2165$export$4e328f61c538687f(props);
    let child = $6saFI$react.Children.only(children);
    return(/*#__PURE__*/ $6saFI$react.cloneElement(child, $6saFI$mergeProps(child.props, {
        ...focusProps,
        className: $6saFI$clsx({
            [focusClass || '']: isFocused,
            [focusRingClass || '']: isFocusVisible
        })
    })));
}


var $391c6482f25a1991$exports = {};

$parcel$export($391c6482f25a1991$exports, "FocusableProvider", () => $391c6482f25a1991$export$13f3202a3e5ddd5);
$parcel$export($391c6482f25a1991$exports, "useFocusable", () => $391c6482f25a1991$export$4c014de7c8940b4c);



let $391c6482f25a1991$var$FocusableContext = /*#__PURE__*/ $6saFI$react.createContext(null);
function $391c6482f25a1991$var$useFocusableContext(ref) {
    let context = $6saFI$useContext($391c6482f25a1991$var$FocusableContext) || {
    };
    $6saFI$useSyncRef(context, ref);
    // eslint-disable-next-line
    let { ref: _ , ...otherProps } = context;
    return otherProps;
}
/**
 * Provides DOM props to the nearest focusable child.
 */ function $391c6482f25a1991$var$FocusableProvider(props, ref) {
    let { children: children , ...otherProps } = props;
    let context = {
        ...otherProps,
        ref: ref
    };
    return(/*#__PURE__*/ $6saFI$react.createElement($391c6482f25a1991$var$FocusableContext.Provider, {
        value: context
    }, children));
}
let $391c6482f25a1991$export$13f3202a3e5ddd5 = /*#__PURE__*/ $6saFI$react.forwardRef($391c6482f25a1991$var$FocusableProvider);
function $391c6482f25a1991$export$4c014de7c8940b4c(props, domRef) {
    let { focusProps: focusProps  } = $6saFI$useFocus(props);
    let { keyboardProps: keyboardProps  } = $6saFI$useKeyboard(props);
    let interactions = $6saFI$mergeProps(focusProps, keyboardProps);
    let domProps = $391c6482f25a1991$var$useFocusableContext(domRef);
    let interactionProps = props.isDisabled ? {
    } : domProps;
    let autoFocusRef = $6saFI$useRef(props.autoFocus);
    $6saFI$useEffect(()=>{
        if (autoFocusRef.current && domRef.current) domRef.current.focus();
        autoFocusRef.current = false;
    }, []);
    return {
        focusableProps: $6saFI$mergeProps({
            ...interactions,
            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
        }, interactionProps)
    };
}






export {$14e5c84cbc2e6e2e$export$20e40289641fbbb6 as FocusScope, $14e5c84cbc2e6e2e$export$10c5169755ce7bd7 as useFocusManager, $14e5c84cbc2e6e2e$export$2d6ec8fc375ceafa as getFocusableTreeWalker, $14e5c84cbc2e6e2e$export$c5251b9e124bf29 as createFocusManager, $503734efc0922182$export$1a38b4ad7f578e1d as FocusRing, $391c6482f25a1991$export$13f3202a3e5ddd5 as FocusableProvider, $391c6482f25a1991$export$4c014de7c8940b4c as useFocusable, $e63d024ca16f2165$export$4e328f61c538687f as useFocusRing, $1159c3b6ba210e4f$export$80f3e147d781571c as focusSafely};
//# sourceMappingURL=module.js.map
